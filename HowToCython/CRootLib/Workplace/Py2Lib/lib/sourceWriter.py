# -*- coding: cp949 -*-
def run(moduleLst, libname, caseSensitive = False):
	libname = libname.strip()
	sourceName = "Python%sManager" % libname
	cmpFncName = "strcmp"
	if not caseSensitive:
		cmpFncName = "_stricmp"

	initSource = open(sourceName + ".cpp", "w")
	initHeader = open(sourceName + ".h", "w")

	initSource.write('#include "%s.h"\n' % sourceName)
	initSource.write('#include "Python.h"\n')
	initSource.write('#ifdef _DEBUG\n')
	initSource.write('	#pragma comment (lib, "%s_d.lib")\n' % libname)
	initSource.write('#else\n')
	initSource.write('	#pragma comment (lib, "%s.lib")\n' % libname)
	initSource.write('#endif\n')
	initSource.write('\n')
	initSource.write('struct %s_SMethodDef\n' % libname)
	initSource.write('{\n')
	initSource.write('	const char* func_name;\n')
	initSource.write('	void (*func)();\n')
	initSource.write('};\n')
	initSource.write('\n')
	#
	for moduleName in moduleLst:
		initFunction = "init%s()" % moduleName
		initSource.write("PyMODINIT_FUNC %s;\n" % initFunction)

	initSource.write('\n')
	initSource.write('%s_SMethodDef %s_init_methods[] =\n' % (libname, libname))
	initSource.write('{\n')
	#
	for moduleName in moduleLst:
		initFunction = "init%s" % moduleName
		initSource.write("	{ \"%s\", %s },\n" % (moduleName, initFunction))

	initSource.write('	{ NULL, NULL },\n')
	initSource.write('};\n')
	initSource.write('\n')
	initSource.write('static PyObject* %s_isExist(PyObject *self, PyObject *args)\n' % libname)
	initSource.write('{\n')
	initSource.write('	char* func_name;\n')
	initSource.write('\n')
	initSource.write('	if(!PyArg_ParseTuple(args, "s", &func_name))\n')
	initSource.write('		return NULL;\n')
	initSource.write('\n')
	initSource.write('	for (int i = 0; NULL != %s_init_methods[i].func_name;i++)\n' % libname)
	initSource.write('	{\n')
	initSource.write('		if (0 == %s(%s_init_methods[i].func_name, func_name))\n' % (cmpFncName, libname))
	initSource.write('		{\n')
	initSource.write('			return Py_BuildValue("i", 1);\n')
	initSource.write('		}\n')
	initSource.write('	}\n')
	initSource.write('	return Py_BuildValue("i", 0);\n')
	initSource.write('}\n')
	initSource.write('\n')
	initSource.write('static PyObject* %s_moduleImport(PyObject *self, PyObject *args)\n' % libname)
	initSource.write('{\n')
	initSource.write('	char* func_name;\n')
	initSource.write('\n')
	initSource.write('	if(!PyArg_ParseTuple(args, "s", &func_name))\n')
	initSource.write('		return NULL;\n')
	initSource.write('\n')
	initSource.write('	for (int i = 0; NULL != %s_init_methods[i].func_name;i++)\n' % libname)
	initSource.write('	{\n')
	initSource.write('		if (0 == %s(%s_init_methods[i].func_name, func_name))\n' % (cmpFncName, libname))
	initSource.write('		{\n')
	initSource.write('			%s_init_methods[i].func();\n' % libname)
	initSource.write('			if (PyErr_Occurred())\n')
	initSource.write('				return NULL;\n')
	initSource.write('			PyObject* m = PyDict_GetItemString(PyImport_GetModuleDict(), %s_init_methods[i].func_name);\n' % libname)
	initSource.write('			if (m == NULL) {\n')
	initSource.write('				PyErr_SetString(PyExc_SystemError,\n')
	initSource.write('					"dynamic module not initialized properly");\n')
	initSource.write('				return NULL;\n')
	initSource.write('			}\n')
	initSource.write('			Py_INCREF(m);\n')
	initSource.write('			return Py_BuildValue("S", m);\n')
	initSource.write('		}\n')
	initSource.write('	}\n')
	initSource.write('	return NULL;\n')
	initSource.write('}\n')
	initSource.write('\n')
	initSource.write('static PyObject* %s_getList(PyObject *self, PyObject *args)\n' % libname)
	initSource.write('{\n')
	initSource.write('	int iTupleSize = 0;\n')
	initSource.write('	while (NULL != %s_init_methods[iTupleSize].func_name) {iTupleSize++;}\n' % libname)
	initSource.write('\n')
	initSource.write('	PyObject* retTuple = PyTuple_New(iTupleSize);\n')
	initSource.write('	for (int i = 0; NULL != %s_init_methods[i].func_name; i++)\n' % libname)
	initSource.write('	{\n')
	initSource.write('		PyObject* retSubString = PyString_FromString(%s_init_methods[i].func_name);\n' % libname)
	initSource.write('		PyTuple_SetItem(retTuple, i, retSubString);\n')
	initSource.write('	}\n')
	initSource.write('	return retTuple;\n')
	initSource.write('}\n')
	initSource.write('\n')
	initSource.write('void init%sManager()\n' % libname)
	initSource.write('{\n')
	initSource.write('	static struct PyMethodDef methods[] =\n')
	initSource.write('	{\n')
	initSource.write('		{"isExist", %s_isExist, METH_VARARGS},\n' % libname)
	initSource.write('		{"moduleImport", %s_moduleImport, METH_VARARGS},\n' % libname)
	initSource.write('		{"getList", %s_getList, METH_VARARGS},\n' % libname)
	initSource.write('		{NULL, NULL},\n')
	initSource.write('	};\n')
	initSource.write('\n')
	initSource.write('	PyObject* m;\n')
	initSource.write('	m = Py_InitModule("%s", methods);\n' % libname)
	initSource.write('}\n')

	initHeader.write('#ifndef __INC_PYTHON_%s_MANAGER_H__\n' % libname)
	initHeader.write('#define __INC_PYTHON_%s_MANAGER_H__\n' % libname)

	initHeader.write("#define init%sManager init%s\n" % (libname, libname))
	initHeader.write("/* %s module */\n" % libname)
	initHeader.write("/* %s.isExist */\n" % libname)
	initHeader.write("/* %s.moduleImport */\n" % libname)
	initHeader.write("/* %s.getList */\n" % libname)
	initHeader.write("/* this lib includes modules under this lines.\n")
	for moduleName in moduleLst:
		initHeader.write("	%s\n" % moduleName)
	initHeader.write("*/\n")
	initHeader.write('void init%sManager();\n' % libname)
	initHeader.write('#endif\n')

	return sourceName
